name: Goliath Auto Tool System

on:
  workflow_dispatch:
  schedule:
    - cron: "0 */8 * * *"

permissions:
  contents: write
  issues: write

concurrency:
  group: goliath-auto
  cancel-in-progress: false

jobs:
  build:
    runs-on: ubuntu-latest
    defaults:
      run:
        shell: bash

    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          # GH_PATがあればそれを使う（pushが安定する）
          token: ${{ secrets.GH_PAT != '' && secrets.GH_PAT || github.token }}

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.10"

      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          if [ -f requirements.txt ]; then
            pip install -r requirements.txt
          fi

      - name: Ensure state files exist
        run: |
          set -euo pipefail
          mkdir -p state
          if [ ! -f state/last_seen.json ]; then
            cat > state/last_seen.json <<'JSON'
          {
            "x_seen": []
          }
          JSON
          fi

      - name: Run Goliath System (capture exit)
        id: goliath_run
        continue-on-error: true
        env:
          OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}

          # ここが今回の事故ポイント：未設定でも必ず"100"
          LEADS_TOTAL: ${{ vars.LEADS_TOTAL || '100' }}

          # Bluesky（旧名 + 新名の両方を渡す：main.py側がどっちでも拾える）
          BSKY_HANDLE: ${{ secrets.BSKY_HANDLE }}
          BSKY_PASSWORD: ${{ secrets.BSKY_PASSWORD }}
          BLUESKY_HANDLE: ${{ secrets.BSKY_HANDLE }}
          BLUESKY_APP_PASSWORD: ${{ secrets.BSKY_PASSWORD }}

          # Mastodon（旧名 + 新名の両方を渡す）
          MASTODON_API_BASE: ${{ secrets.MASTODON_API_BASE }}
          MASTODON_ACCESS_TOKEN: ${{ secrets.MASTODON_ACCESS_TOKEN }}
          MASTODON_BASE: ${{ secrets.MASTODON_API_BASE }}
          MASTODON_TOKEN: ${{ secrets.MASTODON_ACCESS_TOKEN }}

          # Unsplash
          UNSPLASH_ACCESS_KEY: ${{ secrets.UNSPLASH_ACCESS_KEY }}

          # X（旧OAuth1.0a一式：将来使うなら残す）
          X_API_KEY: ${{ secrets.X_API_KEY }}
          X_API_SECRET: ${{ secrets.X_API_SECRET }}
          X_ACCESS_TOKEN: ${{ secrets.X_ACCESS_TOKEN }}
          X_ACCESS_SECRET: ${{ secrets.X_ACCESS_SECRET }}

          # X（Bearer / 検索モード用：入れてあれば自動で使える）
          X_BEARER_TOKEN: ${{ secrets.X_BEARER_TOKEN }}
          X_USER_ID: ${{ secrets.X_USER_ID }}
          X_QUERY: ${{ vars.X_QUERY }}

          # optional
          CLICK_LOG_ENDPOINT: ${{ secrets.CLICK_LOG_ENDPOINT }}

          # ログが遅延しないように
          PYTHONUNBUFFERED: "1"
        run: |
          set +e
          python main.py 2>&1 | tee run_log.txt
          realcode=${PIPESTATUS[0]}

          echo "REAL_EXITCODE=$realcode" >> run_log.txt

          # workflowを赤くしない（あなたの仕様どおり）
          echo "exitcode=0" >> "$GITHUB_OUTPUT"
          # ただし実際の終了コードは保持
          echo "real_exitcode=$realcode" >> "$GITHUB_OUTPUT"

          exit 0

      - name: Commit and Push Changes (exclude run_log)
        if: always()
        run: |
          set -euo pipefail
          git config user.name "Goliath-Bot"
          git config user.email "bot@mikanntool.com"

          # ログはコミットしない（artifactで持つ）
          git add -A ":!run_log.txt" || true

          # state が .gitignore されてても強制で追加（重複防止のために永続化が必要）
          git add -f state/last_seen.json || true

          if git diff --cached --quiet; then
            echo "No changes to commit."
          else
            git commit -m "Goliath: generate pages + replies + design (auto)"
            git push
          fi

      - name: Create Issue Report (ALWAYS)
        if: always()
        env:
          # GH_PATがあるなら優先。無ければ標準トークン。
          GITHUB_TOKEN: ${{ secrets.GH_PAT != '' && secrets.GH_PAT || github.token }}
          REAL_EXITCODE: ${{ steps.goliath_run.outputs.real_exitcode }}

          # report側でも必要なら渡す（mainと同じ）
          X_API_KEY: ${{ secrets.X_API_KEY }}
          X_API_SECRET: ${{ secrets.X_API_SECRET }}
          X_ACCESS_TOKEN: ${{ secrets.X_ACCESS_TOKEN }}
          X_ACCESS_SECRET: ${{ secrets.X_ACCESS_SECRET }}
          X_BEARER_TOKEN: ${{ secrets.X_BEARER_TOKEN }}
          X_USER_ID: ${{ secrets.X_USER_ID }}
          X_QUERY: ${{ vars.X_QUERY }}
        run: |
          python tools/report_to_issue.py

      - name: Upload run log
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: goliath-run-log
          path: run_log.txt
      - name: Find issues payload json
        id: find_payload
        shell: bash
        run: |
          set -euo pipefail
          f="$(ls -t goliath/_out/issues_payload_*.json 2>/dev/null | head -n 1 || true)"
          echo "payload=$f" >> "$GITHUB_OUTPUT"
          if [ -z "$f" ]; then
            echo "No issues_payload_*.json found under goliath/_out/"
          else
            echo "Found payload: $f"
          fi

      - name: Create GitHub Issue from payload
        uses: actions/github-script@v7
        env:
          PAYLOAD_JSON: ${{ steps.find_payload.outputs.payload }}
        with:
          github-token: ${{ secrets.GH_PAT != '' && secrets.GH_PAT || github.token }}
          script: |
            const core = require('@actions/core');
            const fs = require('fs');

            const p = process.env.PAYLOAD_JSON;
            if (!p) {
              core.warning('PAYLOAD_JSON is empty. Skip creating issue.');
              return;
            }
            if (!fs.existsSync(p)) {
              core.setFailed(`Payload not found: ${p}`);
              return;
            }

            const data = JSON.parse(fs.readFileSync(p, 'utf8'));
            const runId = data.run_id ?? 'unknown';
            const count = data.count ?? 0;
            const issues = Array.isArray(data.issues) ? data.issues : [];

            if (issues.length === 0) {
              core.warning(`No issues in payload: ${p}`);
              return;
            }

            // 1つのIssueにまとめて「羅列」する（スパム防止）
            const title = `Goliath candidates (RUN_ID=${runId}) count=${count}`;
            const body = issues.map(x => `## ${x.title}\n\n${x.body}`).join('\n\n---\n\n');

            await github.rest.issues.create({
              owner: context.repo.owner,
              repo: context.repo.repo,
              title,
              body
            });

            core.info(`Created 1 issue from ${p} (parts=${issues.length})`);
